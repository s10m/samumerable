using System;
using System.Collections.Generic;
using System.Text;

namespace Samumerable.Tests
{
    public class ARefType
    {
        public ARefType(int p_Reference)
        {
            Reference = p_Reference;
        }
        public int Reference { get; }
        public int A { get; set; }
        public ARefType B { get; set; }

        public override bool Equals(object obj)
        {
            return (obj as ARefType)?.Reference == Reference;
        }

        public override int GetHashCode()
        {
            return Reference.GetHashCode();
        }
    }

    public class Util
    {
        /// <summary>
        /// Generates an array of integers with the given size and elements generated by the given method.
        /// </summary>
        /// <param name="p_NumberOfElements">The numebr of elements to put in the array. Should not be negative.</param>
        /// <param name="p_IndexItemGenerator">A function for generating items based on their index.</param>
        /// <returns>An array filled appropriately.</returns>
        /// <exception cref="ArgumentOutOfRangeException">If <paramref name="p_NumberOfElements"/> is negative.</exception>
        public IEnumerable<int> IntArray(int p_NumberOfElements, Func<int, int> p_IndexItemGenerator)
        {
            VerifyIndex(p_NumberOfElements);

            return EagerFillArray(p_NumberOfElements, p_IndexItemGenerator);
        }

        public IEnumerable<int> IntList(int p_NumberOfElements, Func<int, int> p_IndexItemGenerator)
        {
            VerifyIndex(p_NumberOfElements);

            return EagerFillList(p_NumberOfElements, p_IndexItemGenerator);
        }

        public IEnumerable<int> IntLazy(int p_NumberOfElements, Func<int, int> p_IndexItemGenerator)
        {
            VerifyIndex(p_NumberOfElements);

            return LazyEnumerable(p_NumberOfElements, p_IndexItemGenerator);
        }

        private IEnumerable<T> LazyEnumerable<T>(int p_NumberOfElements, Func<int, T> p_IndexItemGenerator)
        {
            for (int index = 0; index < p_NumberOfElements; index++)
            {
                yield return p_IndexItemGenerator(index);
            }
        }

        public IEnumerable<ARefType> ClassArray(int p_NumberOfElements, Func<int, ARefType> p_IndexItemGenerator)
        {
            VerifyIndex(p_NumberOfElements);

            return EagerFillArray(p_NumberOfElements, p_IndexItemGenerator);
        }

        public IEnumerable<ARefType> ClassList(int p_NumberOfElements, Func<int, ARefType> p_IndexItemGenerator)
        {
            VerifyIndex(p_NumberOfElements);

            return EagerFillList(p_NumberOfElements, p_IndexItemGenerator);
        }

        public IEnumerable<ARefType> ClassLazy(int p_NumberOfElements, Func<int, ARefType> p_IndexItemGenerator)
        {
            VerifyIndex(p_NumberOfElements);

            return LazyEnumerable(p_NumberOfElements, p_IndexItemGenerator);
        }

        private void VerifyIndex(int p_NumberOfElements)
        {
            if (p_NumberOfElements < 0)
            {
                throw new ArgumentOutOfRangeException(nameof(p_NumberOfElements), $"{nameof(p_NumberOfElements)} should not be negative");
            }
        }

        private T[] EagerFillArray<T>(int p_NumberOfElements, Func<int, T> p_IndexItemGenerator)
        {
            T[] result = new T[p_NumberOfElements];

            for (int elementIndex = 0; elementIndex < p_NumberOfElements; elementIndex++)
            {
                result[elementIndex] = p_IndexItemGenerator(elementIndex);
            }

            return result;
        }

        private List<T> EagerFillList<T>(int p_NumberOfElements, Func<int, T> p_IndexItemGenerator)
        {
            List<T> result = new List<T>(p_NumberOfElements);

            for (int elementIndex = 0; elementIndex < p_NumberOfElements; elementIndex++)
            {
                result[elementIndex] = p_IndexItemGenerator(elementIndex);
            }

            return result;
        }
    }
}
